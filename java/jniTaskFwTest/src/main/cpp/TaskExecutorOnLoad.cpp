#include <iostream>  // for std::cout#include <jni.h>#include "JavaObject.h"#include "ThrowJavaRuntimeException.h"#include "JniAssert.h"#include "TaskExecutor.h"#include "JavaClassConst.h"#include "TaskExecutorJNI.h"static JNINativeMethod method_table[] = { { (char*) "initCpp", (char*) "()V",		(void *) initCpp }, { (char*) "executeCpp", (char*) "()V",		(void *) executeCpp }, { (char*) "disposeCpp", (char*) "()V",		(void *) disposeCpp } };static int method_table_size = sizeof(method_table) / sizeof(method_table[0]);jint JNI_OnLoad(JavaVM* vm, void* reserved) {	std::cout << "TaskExecutor: JNI_OnLoad ENTER" << std::endl;	JNIEnv* env;	if (vm->GetEnv((void **) &env, JNI_VERSION_1_6) != JNI_OK) {		std::cout << "JNI_OnLoad LEAVE: returning  JNI_ERR" << std::endl;		return JNI_ERR;	}	// The app is storing pointers in Java long. Check that there is enough space.	if (sizeof(jlong) < sizeof(void *)) {		std::cout << "JNI_OnLoad LEAVE: error, sizeof(void *) > sizeof(jlong)"				<< std::endl;		return JNI_ERR;	}	jclass clazz = env->FindClass(JavaClassConst::CLASSNAME_TASKEXECUTOR);	if (clazz) {		jint ret = env->RegisterNatives(clazz, method_table, method_table_size);		env->DeleteLocalRef(clazz);		std::cout				<< "TaskExecutor: JNI_OnLoad LEAVE, registeredNatives, status "				<< ret << std::endl;		return ret == 0 ? JNI_VERSION_1_6 : JNI_ERR;	} else {		std::cout				<< "TaskExecutor: JNI_OnLoad LEAVE, failed to locate TaskExecutor class"				<< std::endl;		return JNI_ERR;	}}